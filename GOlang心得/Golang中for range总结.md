## Golang中for range总结

从前面的演示中可以看出，range背后对需要循环的对象做了复制操作，并且不是简单直接的按照原来的内存布局复制的，比如struct,复制操作会把同类型元素全部存放在一个内存块中，所以扫量元素的循环中，每一个字段有自己独有的索引，但是循环每一个值，索引不会发生变化，这在实际操作中会遇到很多意想不到的坑。

而我们知道struct在内存中是一段连续的内存，但是每一个字段每一个值都有自己独有的指针地址，所以我们在想要改变原始struct中数据，或者以原始struct为基础，生成其他数据，但不需要改变这些数据的时候，最好使用原始结构体，以及其中元素的指针操作，这样不会有引用数据重复，大量内存开销等问题。

而针对需要改变数据，或者新数据隔绝与原始数据的联系，避免数据污染的问题，就不要在整个for range过程中使用任何的指针行为，尽量采用值传递的方式，虽然性能有影响，但是数据安全。

仔细思考range的优缺点后，发现range更适合使用在那些与原始数据隔绝的使用场景，range本身在循环前已经对数据重新复制生成适合循环的结构了，开销不会太大，同时对原始数据不产生影响

